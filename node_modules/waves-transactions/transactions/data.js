"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const waves_crypto_1 = require("waves-crypto");
const transactions_1 = require("../transactions");
const generic_1 = require("../generic");
const validation_1 = require("../validation");
const schemas_1 = require("../schemas");
const typeMap = {
    integer: ['integer', 0, waves_crypto_1.LONG],
    number: ['integer', 0, waves_crypto_1.LONG],
    boolean: ['boolean', 1, waves_crypto_1.BYTE],
    string: ['string', 3, waves_crypto_1.LEN(waves_crypto_1.SHORT)(waves_crypto_1.STRING)],
    binary: ['binary', 2, (s) => waves_crypto_1.LEN(waves_crypto_1.SHORT)(waves_crypto_1.BASE64_STRING)(s.slice(7))],
    _: ['binary', 2, waves_crypto_1.LEN(waves_crypto_1.SHORT)(waves_crypto_1.BYTES)],
};
const mapType = (value) => typeMap[typeof value] || typeMap['_'];
exports.dataValidation = (tx) => [];
exports.dataToBytes = (tx) => waves_crypto_1.concat(waves_crypto_1.BYTE(transactions_1.TransactionType.Data), waves_crypto_1.BYTE(1), waves_crypto_1.BASE58_STRING(tx.senderPublicKey), waves_crypto_1.COUNT(waves_crypto_1.SHORT)((x) => waves_crypto_1.concat(waves_crypto_1.LEN(waves_crypto_1.SHORT)(waves_crypto_1.STRING)(x.key), [typeMap[x.type][1]], typeMap[x.type][2](x.value)))(tx.data), waves_crypto_1.LONG(tx.timestamp), waves_crypto_1.LONG(tx.fee));
/**
 * Creates and signs [[DataTransaction]].
 *
 * You can use this function with multiple seeds. In this case it will sign transaction accordingly and will add one proof per seed.
 * Also you can use already signed [[DataTransaction]] as a second argument.
 *
 * ### Usage
 * ```js
 * const { data } = require('waves-transactions')
 *
 * const seed = 'b716885e9ba64442b4f1263c8e2d8671e98b800c60ec4dc2a27c83e5f9002b18'
 *
 * const params = {
 *   data: [
 *     { key: 'integerVal', value: 1 },
 *     { key: 'booleanVal', value: true },
 *     { key: 'stringVal', value: 'hello' },
 *     { key: 'binaryVal', value: [1, 2, 3, 4] },
 *   ],
 *   //timestamp: Date.now(),
 *   //fee: 100000 + bytes.length * 100000
 * }
 *
 * const signedDataTx = data(params, seed)
 * ```
 * ### Output
 * ```json
 * {
 *   "id": "9ysRcXjwpHq46PUSamfWMnq2nUWoFS9rAnDgs4ynqRvU",
 *   "type": 12,
 *   "version": 1,
 *   "senderPublicKey": "G62H1XE5rnaCgCCURV5pWwQHzWezZB7VkkVgqthdKgkj",
 *   "fee": 100000,
 *   "timestamp": 1542716926639,
 *   "proofs": [
 *     "MbAgcTmniTasof8SuogFComQZB4fGV9UTbbKV1rTwgakb8xiDTmk47dkCKX8Y5xXAK848rSL4jJjarMLFiyifoy"
 *   ],
 *   "data": [
 *     {
 *       "type": "integer",
 *       "key": "integerVal",
 *       "value": 1
 *     },
 *     {
 *       "type": "boolean",
 *       "key": "booleanVal",
 *       "value": true
 *     },
 *     {
 *       "type": "string",
 *       "key": "stringVal",
 *       "value": "hello"
 *     },
 *     {
 *       "type": "binary",
 *       "key": "binaryVal",
 *       "value": "base64:AQIDBA=="
 *     }
 *   ]
 * }
 * ```
 *
 * @param seed
 * @param paramsOrTx
 * @returns
 *
 */
function data(paramsOrTx, seed) {
    const { nextSeed } = generic_1.pullSeedAndIndex(seed);
    const { data: _data, fee, timestamp } = paramsOrTx;
    const senderPublicKey = generic_1.getSenderPublicKey(seed, paramsOrTx);
    if (!Array.isArray(_data))
        throw new Error('["data should be array"]');
    const _timestamp = generic_1.valOrDef(timestamp, Date.now());
    let bytes = waves_crypto_1.concat(waves_crypto_1.BYTE(transactions_1.TransactionType.Data), waves_crypto_1.BYTE(1), waves_crypto_1.BASE58_STRING(senderPublicKey), waves_crypto_1.COUNT(waves_crypto_1.SHORT)((x) => waves_crypto_1.concat(waves_crypto_1.LEN(waves_crypto_1.SHORT)(waves_crypto_1.STRING)(x.key), [mapType(x.value)[1]], mapType(x.value)[2](x.value)))(_data), waves_crypto_1.LONG(_timestamp));
    const computedFee = (Math.floor(1 + (bytes.length + 8 /*feeLong*/ - 1) / 1024) * 100000);
    const tx = Object.assign({ type: 12, version: 1, senderPublicKey, fee: computedFee, timestamp: _timestamp, proofs: [], id: '' }, paramsOrTx, { data: _data && _data.map((x) => {
            if (x.type)
                return x;
            else {
                const type = mapType(x.value)[0];
                return {
                    type,
                    key: x.key,
                    value: type === 'binary' ? 'base64:' + Buffer.from(x.value).toString('base64') : x.value,
                };
            }
        }) });
    validation_1.raiseValidationErrors(validation_1.generalValidation(tx, schemas_1.validators.DataTransaction), exports.dataValidation(tx));
    bytes = exports.dataToBytes(tx);
    generic_1.mapSeed(seed, (s, i) => generic_1.addProof(tx, waves_crypto_1.signBytes(bytes, s), i));
    tx.id = waves_crypto_1.hashBytes(bytes);
    return nextSeed ? data(tx, nextSeed) : tx;
}
exports.data = data;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy90cmFuc2FjdGlvbnMvZGF0YS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLCtDQWFxQjtBQUNyQixrREFBNkY7QUFDN0Ysd0NBQThGO0FBRzlGLDhDQUF3RTtBQUN4RSx3Q0FBdUM7QUFhdkMsTUFBTSxPQUFPLEdBQVE7SUFDbkIsT0FBTyxFQUFFLENBQUMsU0FBUyxFQUFFLENBQUMsRUFBRSxtQkFBSSxDQUFDO0lBQzdCLE1BQU0sRUFBRSxDQUFDLFNBQVMsRUFBRSxDQUFDLEVBQUUsbUJBQUksQ0FBQztJQUM1QixPQUFPLEVBQUUsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxFQUFFLG1CQUFJLENBQUM7SUFDN0IsTUFBTSxFQUFFLENBQUMsUUFBUSxFQUFFLENBQUMsRUFBRSxrQkFBRyxDQUFDLG9CQUFLLENBQUMsQ0FBQyxxQkFBTSxDQUFDLENBQUM7SUFDekMsTUFBTSxFQUFFLENBQUMsUUFBUSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQVEsRUFBRSxFQUFFLENBQUMsa0JBQUcsQ0FBQyxvQkFBSyxDQUFDLENBQUMsNEJBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMxRSxDQUFDLEVBQUUsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxFQUFFLGtCQUFHLENBQUMsb0JBQUssQ0FBQyxDQUFDLG9CQUFLLENBQUMsQ0FBQztDQUNwQyxDQUFBO0FBRUQsTUFBTSxPQUFPLEdBQUcsQ0FBSSxLQUFRLEVBQXFDLEVBQUUsQ0FDakUsT0FBTyxDQUFDLE9BQU8sS0FBSyxDQUFDLElBQUksT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFBO0FBRTFCLFFBQUEsY0FBYyxHQUFHLENBQUMsRUFBbUIsRUFBb0IsRUFBRSxDQUFDLEVBQUUsQ0FBQTtBQUU5RCxRQUFBLFdBQVcsR0FBRyxDQUFDLEVBQW1CLEVBQWMsRUFBRSxDQUFDLHFCQUFNLENB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