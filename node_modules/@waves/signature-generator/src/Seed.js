"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Config_1 = require("./config/Config");
const index_1 = require("./index");
const dictionary_1 = require("./dictionary");
class Seed {
    constructor(phrase) {
        if (phrase.length < Config_1.config.get('minimalSeedLength')) {
            throw new Error('Your seed length is less than allowed in config');
        }
        const keys = index_1.utils.crypto.buildKeyPair(phrase);
        this.phrase = phrase;
        this.address = index_1.utils.crypto.buildRawAddress(keys.publicKey);
        this.keyPair = {
            privateKey: index_1.libs.base58.encode(keys.privateKey),
            publicKey: index_1.libs.base58.encode(keys.publicKey)
        };
        Object.freeze(this);
        Object.freeze(this.keyPair);
    }
    encrypt(password, encryptionRounds) {
        return Seed.encryptSeedPhrase(this.phrase, password, encryptionRounds);
    }
    static encryptSeedPhrase(seedPhrase, password, encryptionRounds = 5000) {
        if (password && password.length < 8) {
            // logger.warn('Your password may be too weak');
        }
        if (encryptionRounds < 1000) {
            // logger.warn('Encryption rounds may be too few');
        }
        if (seedPhrase.length < Config_1.config.get('minimalSeedLength')) {
            throw new Error('The seed phrase you are trying to encrypt is too short');
        }
        return index_1.utils.crypto.encryptSeed(seedPhrase, password, encryptionRounds);
    }
    static decryptSeedPhrase(encryptedSeedPhrase, password, encryptionRounds = 5000) {
        const wrongPasswordMessage = 'The password is wrong';
        let phrase;
        try {
            phrase = index_1.utils.crypto.decryptSeed(encryptedSeedPhrase, password, encryptionRounds);
        }
        catch (e) {
            throw new Error(wrongPasswordMessage);
        }
        if (phrase === '' || phrase.length < Config_1.config.get('minimalSeedLength')) {
            throw new Error(wrongPasswordMessage);
        }
        return phrase;
    }
    static create(words = 15) {
        const phrase = Seed._generateNewSeed(words);
        const minimumSeedLength = Config_1.config.get('minimalSeedLength');
        if (phrase.length < minimumSeedLength) {
            // If you see that error you should increase the number of words in the generated seed
            throw new Error(`The resulted seed length is less than the minimum length (${minimumSeedLength})`);
        }
        return new Seed(phrase);
    }
    static fromExistingPhrase(phrase) {
        const minimumSeedLength = Config_1.config.get('minimalSeedLength');
        if (phrase.length < minimumSeedLength) {
            // If you see that error you should increase the number of words or set it lower in the config
            throw new Error(`The resulted seed length is less than the minimum length (${minimumSeedLength})`);
        }
        return new Seed(phrase);
    }
    static _generateNewSeed(length) {
        const random = index_1.utils.crypto.generateRandomUint32Array(length);
        const wordCount = dictionary_1.default.length;
        const phrase = [];
        for (let i = 0; i < length; i++) {
            const wordIndex = random[i] % wordCount;
            phrase.push(dictionary_1.default[wordIndex]);
        }
        random.set(new Uint8Array(random.length));
        return phrase.join(' ');
    }
}
exports.Seed = Seed;
