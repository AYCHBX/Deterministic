"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var __1 = require("..");
var concat_1 = require("../utils/concat");
var crypto_1 = require("../utils/crypto");
var ERRORS = {
    NO_DATA: { code: 'NO_DATA', message: 'No data' },
    FIELD_ERROR: { code: 'FIELD_ERROR', message: 'Invalid field', field: null },
};
function generate(fields) {
    var errors = [];
    if (!fields || !fields.length) {
        errors.push(ERRORS.NO_DATA);
    }
    // Fields of the original data object
    var storedFields = Object.create(null);
    // Data bytes or functions returning data bytes via promises
    var byteProviders = [];
    fields.forEach(function (field) {
        if (field instanceof __1.ByteProcessor) {
            // Remember user data fields
            storedFields[field.name] = field;
            // All user data must be represented as bytes
            byteProviders.push(function (data) {
                try {
                    return field.process(data[field.name]);
                }
                catch (e) {
                    throw __assign({}, ERRORS.FIELD_ERROR, { field: field.name, message: e.message });
                }
            });
        }
        else if (typeof field === 'number') {
            // All static data must be converted to bytes as well
            byteProviders.push(Uint8Array.from([field]));
        }
        else {
            errors.push(__assign({}, ERRORS.FIELD_ERROR, { field: field }));
        }
    });
    if (errors.length) {
        throw errors;
    }
    var SignatureGenerator = /** @class */ (function () {
        function SignatureGenerator(hashMap) {
            if (hashMap === void 0) { hashMap = {}; }
            var _this = this;
            this._errors = [];
            // Save all needed values from user data
            this._rawData = Object.keys(storedFields).reduce(function (store, key) {
                store[key] = hashMap[key];
                return store;
            }, {});
            this._dataHolders = byteProviders.map(function (provider) {
                if (typeof provider === 'function') {
                    // Execute function so that they return promises containing Uint8Array data
                    try {
                        return provider(_this._rawData);
                    }
                    catch (e) {
                        _this._errors.push(e);
                    }
                }
                else {
                    // Or just pass Uint8Array data
                    return provider;
                }
            });
            if (this._errors.length) {
                throw this._errors;
            }
        }
        SignatureGenerator.prototype.getSignature = function (privateKey) {
            return this.getBytes().then(function (dataBytes) {
                return crypto_1.default.buildTransactionSignature(dataBytes, privateKey);
            });
        };
        // Get byte representation of the transaction
        SignatureGenerator.prototype.getBytes = function () {
            return Promise.all(this._dataHolders).then(function (multipleDataBytes) {
                if (multipleDataBytes.length === 1) {
                    return multipleDataBytes[0];
                }
                else {
                    return concat_1.concatUint8Arrays.apply(void 0, multipleDataBytes);
                }
            });
        };
        SignatureGenerator.prototype.getDebugBytes = function () {
            var _this = this;
            return Promise.all(fields.map(function (field, i) {
                var value = field && field.name ? _this._rawData[field.name] : null;
                var result = _this._dataHolders[i];
                if (result instanceof Promise) {
                    return result.then(function (bytes) {
                        return { bytes: bytes, from: field && field.name || field, value: value };
                    });
                }
                else {
                    return Promise.resolve({ bytes: result, from: field, value: value });
                }
            }));
        };
        // Get bytes of an exact field from user data
        SignatureGenerator.prototype.getExactBytes = function (fieldName) {
            if (!(fieldName in storedFields)) {
                throw new Error("There is no field '" + fieldName + "' in 'RequestDataType class");
            }
            var byteProcessor = storedFields[fieldName];
            var userData = this._rawData[fieldName];
            return byteProcessor.process(userData);
        };
        return SignatureGenerator;
    }());
    return SignatureGenerator;
}
exports.generate = generate;
exports.TX_NUMBER_MAP = Object.create(null);
exports.TX_TYPE_MAP = Object.create(null);
exports.CREATE_ORDER_SIGNATURE = generate([
    new __1.Base58('senderPublicKey'),
    new __1.Base58('matcherPublicKey'),
    new __1.AssetId('amountAsset'),
    new __1.AssetId('priceAsset'),
    new __1.OrderType('orderType'),
    new __1.Long('price'),
    new __1.Long('amount'),
    new __1.Long('timestamp'),
    new __1.Long('expiration'),
    new __1.Long('matcherFee')
]);
exports.AUTH_ORDER_SIGNATURE = generate([
    new __1.Base58('senderPublicKey'),
    new __1.Long('timestamp')
]);
exports.CANCEL_ORDER_SIGNATURE = generate([
    new __1.Base58('senderPublicKey'),
    new __1.Base58('orderId')
]);
var ISSUE = generate([
    3 /* ISSUE */,
    2 /* ISSUE */,
    new __1.Byte('chainId'),
    new __1.Base58('senderPublicKey'),
    new __1.StringWithLength('name'),
    new __1.StringWithLength('description'),
    new __1.Long('quantity'),
    new __1.Byte('precision'),
    new __1.Bool('reissuable'),
    new __1.Long('fee'),
    new __1.Long('timestamp'),
    0 // Byte for script smart assets.
]);
exports.TX_NUMBER_MAP[3 /* ISSUE */] = ISSUE;
exports.TX_TYPE_MAP["issue" /* ISSUE */] = ISSUE;
var TRANSFER = generate([
    4 /* TRANSFER */,
    2 /* TRANSFER */,
    new __1.Base58('senderPublicKey'),
    new __1.AssetId('assetId'),
    new __1.AssetId('feeAssetId'),
    new __1.Long('timestamp'),
    new __1.Long('amount'),
    new __1.Long('fee'),
    new __1.Recipient('recipient'),
    new __1.Attachment('attachment')
]);
exports.TX_NUMBER_MAP[4 /* TRANSFER */] = TRANSFER;
exports.TX_TYPE_MAP["transfer" /* TRANSFER */] = TRANSFER;
var REISSUE = generate([
    5 /* REISSUE */,
    2 /* REISSUE */,
    new __1.Byte('chainId'),
    new __1.Base58('senderPublicKey'),
    new __1.MandatoryAssetId('assetId'),
    new __1.Long('quantity'),
    new __1.Bool('reissuable'),
    new __1.Long('fee'),
    new __1.Long('timestamp')
]);
exports.TX_NUMBER_MAP[5 /* REISSUE */] = REISSUE;
exports.TX_TYPE_MAP["reissue" /* REISSUE */] = REISSUE;
var BURN = generate([
    6 /* BURN */,
    2 /* BURN */,
    new __1.Byte('chainId'),
    new __1.Base58('senderPublicKey'),
    new __1.MandatoryAssetId('assetId'),
    new __1.Long('quantity'),
    new __1.Long('fee'),
    new __1.Long('timestamp')
]);
exports.TX_NUMBER_MAP[6 /* BURN */] = BURN;
exports.TX_TYPE_MAP["burn" /* BURN */] = BURN;
var LEASE = generate([
    8 /* LEASE */,
    2 /* LEASE */,
    0,
    new __1.Base58('senderPublicKey'),
    new __1.Recipient('recipient'),
    new __1.Long('amount'),
    new __1.Long('fee'),
    new __1.Long('timestamp')
]);
exports.TX_NUMBER_MAP[8 /* LEASE */] = LEASE;
exports.TX_TYPE_MAP["lease" /* LEASE */] = LEASE;
var CANCEL_LEASING = generate([
    9 /* CANCEL_LEASING */,
    2 /* CANCEL_LEASING */,
    new __1.Byte('chainId'),
    new __1.Base58('senderPublicKey'),
    new __1.Long('fee'),
    new __1.Long('timestamp'),
    new __1.Base58('transactionId')
]);
exports.TX_NUMBER_MAP[9 /* CANCEL_LEASING */] = CANCEL_LEASING;
exports.TX_TYPE_MAP["cancelLeasing" /* CANCEL_LEASING */] = CANCEL_LEASING;
var CREATE_ALIAS = generate([
    10 /* CREATE_ALIAS */,
    2 /* CREATE_ALIAS */,
    new __1.Base58('senderPublicKey'),
    new __1.Alias('alias'),
    new __1.Long('fee'),
    new __1.Long('timestamp')
]);
exports.TX_NUMBER_MAP[10 /* CREATE_ALIAS */] = CREATE_ALIAS;
exports.TX_TYPE_MAP["createAlias" /* CREATE_ALIAS */] = CREATE_ALIAS;
var MASS_TRANSFER = generate([
    11 /* MASS_TRANSFER */,
    1 /* MASS_TRANSFER */,
    new __1.Base58('senderPublicKey'),
    new __1.AssetId('assetId'),
    new __1.Transfers('transfers'),
    new __1.Long('timestamp'),
    new __1.Long('fee'),
    new __1.Attachment('attachment')
]);
exports.TX_NUMBER_MAP[11 /* MASS_TRANSFER */] = MASS_TRANSFER;
exports.TX_TYPE_MAP["massTransfer" /* MASS_TRANSFER */] = MASS_TRANSFER;
var DATA = generate([
    12 /* DATA */,
    1 /* DATA */,
    new __1.Base58('senderPublicKey'),
    new __1.DataEntries('data'),
    new __1.Long('timestamp'),
    new __1.Long('fee')
]);
exports.TX_NUMBER_MAP[12 /* DATA */] = DATA;
exports.TX_TYPE_MAP["data" /* DATA */] = DATA;
var SET_SCRIPT = generate([
    13 /* SET_SCRIPT */,
    1 /* SET_SCRIPT */,
    new __1.Byte('chainId'),
    new __1.Base58('senderPublicKey'),
    new __1.ScriptVersion('script'),
    new __1.Base64('script'),
    new __1.Long('fee'),
    new __1.Long('timestamp')
]);
exports.TX_NUMBER_MAP[13 /* SET_SCRIPT */] = SET_SCRIPT;
exports.TX_TYPE_MAP["setScript" /* SET_SCRIPT */] = SET_SCRIPT;
var SPONSORSHIP = generate([
    14 /* SPONSORSHIP */,
    1 /* SPONSORSHIP */,
    new __1.Base58('senderPublicKey'),
    new __1.Base58('assetId'),
    new __1.Long('minSponsoredAssetFee'),
    new __1.Long('fee'),
    new __1.Long('timestamp')
]);
exports.TX_NUMBER_MAP[14 /* SPONSORSHIP */] = SPONSORSHIP;
exports.TX_TYPE_MAP["sponsorship" /* SPONSORSHIP */] = SPONSORSHIP;
//# sourceMappingURL=SignatureFactory.js.map