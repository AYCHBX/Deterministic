"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var data_entities_1 = require("@waves/data-entities");
var base64_js_1 = require("base64-js");
var base58_1 = require("../libs/base58");
var convert_1 = require("../utils/convert");
var concat_1 = require("../utils/concat");
var constants_1 = require("../constants");
var __1 = require("..");
var constants_2 = require("../constants");
// NOTE : Waves asset ID in blockchain transactions equals to an empty string
function blockchainifyAssetId(assetId) {
    if (!assetId)
        throw new Error('Asset ID should not be empty');
    return assetId === constants_2.WAVES_ID ? constants_2.WAVES_BLOCKCHAIN_ID : assetId;
}
function getAliasBytes(alias) {
    var aliasBytes = convert_1.default.stringToByteArrayWithSize(alias);
    return [constants_2.ALIAS_VERSION, __1.config.getNetworkByte()].concat(aliasBytes);
}
function isNonEmptyBase64String(value) {
    var pure = value.replace('base64:', '');
    return pure.length > 0 && pure.length % 4 === 0;
}
// ABSTRACT PARENT
var ByteProcessor = /** @class */ (function () {
    function ByteProcessor(name) {
        this.name = name;
    }
    return ByteProcessor;
}());
exports.ByteProcessor = ByteProcessor;
// SIMPLE
var Base58 = /** @class */ (function (_super) {
    __extends(Base58, _super);
    function Base58() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Base58.prototype.process = function (value) {
        var bytes = base58_1.default.decode(value);
        return Promise.resolve(bytes);
    };
    return Base58;
}(ByteProcessor));
exports.Base58 = Base58;
var Base64 = /** @class */ (function (_super) {
    __extends(Base64, _super);
    function Base64() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Base64.prototype.process = function (value) {
        if (typeof value !== 'string')
            throw new Error('You should pass a string to BinaryDataEntry constructor');
        if (isNonEmptyBase64String(value)) {
            if (value.slice(0, 7) !== 'base64:')
                throw new Error('Blob should be encoded in base64 and prefixed with "base64:"');
            var b64 = value.slice(7); // Getting the string payload
            var bytes = Uint8Array.from(base64_js_1.toByteArray(b64));
            var lengthBytes = Uint8Array.from(convert_1.default.shortToByteArray(bytes.length));
            return Promise.resolve(concat_1.concatUint8Arrays(lengthBytes, bytes));
        }
        else {
            return Promise.resolve(Uint8Array.from([]));
        }
    };
    return Base64;
}(ByteProcessor));
exports.Base64 = Base64;
var Bool = /** @class */ (function (_super) {
    __extends(Bool, _super);
    function Bool() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Bool.prototype.process = function (value) {
        var bytes = convert_1.default.booleanToBytes(value);
        return Promise.resolve(Uint8Array.from(bytes));
    };
    return Bool;
}(ByteProcessor));
exports.Bool = Bool;
var Byte = /** @class */ (function (_super) {
    __extends(Byte, _super);
    function Byte() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Byte.prototype.process = function (value) {
        if (typeof value !== 'number')
            throw new Error('You should pass a number to Byte constructor');
        if (value < 0 || value > 255)
            throw new Error('Byte value must fit between 0 and 255');
        return Promise.resolve(Uint8Array.from([value]));
    };
    return Byte;
}(ByteProcessor));
exports.Byte = Byte;
var Long = /** @class */ (function (_super) {
    __extends(Long, _super);
    function Long() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Long.prototype.process = function (value) {
        var bytes;
        if (typeof value === 'number') {
            bytes = convert_1.default.longToByteArray(value);
        }
        else {
            if (typeof value === 'string') {
                value = new data_entities_1.BigNumber(value);
            }
            bytes = convert_1.default.bigNumberToByteArray(value);
        }
        return Promise.resolve(Uint8Array.from(bytes));
    };
    return Long;
}(ByteProcessor));
exports.Long = Long;
var Short = /** @class */ (function (_super) {
    __extends(Short, _super);
    function Short() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Short.prototype.process = function (value) {
        if (typeof value !== 'number')
            throw new Error('You should pass a number to Short constructor');
        if (value < 0 || value > 65535)
            throw new Error('Short value must fit between 0 and 65535');
        return Promise.resolve(Uint8Array.from(convert_1.default.shortToByteArray(value)));
    };
    return Short;
}(ByteProcessor));
exports.Short = Short;
var StringWithLength = /** @class */ (function (_super) {
    __extends(StringWithLength, _super);
    function StringWithLength() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    StringWithLength.prototype.process = function (value) {
        var bytesWithLength = convert_1.default.stringToByteArrayWithSize(value);
        return Promise.resolve(Uint8Array.from(bytesWithLength));
    };
    return StringWithLength;
}(ByteProcessor));
exports.StringWithLength = StringWithLength;
// COMPLEX
var Alias = /** @class */ (function (_super) {
    __extends(Alias, _super);
    function Alias() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Alias.prototype.process = function (value) {
        var aliasBytes = getAliasBytes(value);
        var aliasBytesWithLength = convert_1.default.bytesToByteArrayWithSize(aliasBytes);
        return Promise.resolve(Uint8Array.from(aliasBytesWithLength));
    };
    return Alias;
}(ByteProcessor));
exports.Alias = Alias;
var AssetId = /** @class */ (function (_super) {
    __extends(AssetId, _super);
    function AssetId() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AssetId.prototype.process = function (value) {
        value = blockchainifyAssetId(value);
        // We must pass bytes of `[0]` for Waves asset ID and bytes of `[1] + assetId` for other asset IDs
        var bytes = value ? concat_1.concatUint8Arrays(Uint8Array.from([1]), base58_1.default.decode(value)) : Uint8Array.from([0]);
        return Promise.resolve(bytes);
    };
    return AssetId;
}(ByteProcessor));
exports.AssetId = AssetId;
var Attachment = /** @class */ (function (_super) {
    __extends(Attachment, _super);
    function Attachment() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Attachment.prototype.process = function (value) {
        if (typeof value === 'string') {
            value = Uint8Array.from(convert_1.default.stringToByteArray(value));
        }
        if (value.length > constants_2.TRANSFER_ATTACHMENT_BYTE_LIMIT) {
            throw new Error('Maximum attachment length is exceeded');
        }
        var valueWithLength = convert_1.default.bytesToByteArrayWithSize(value);
        return Promise.resolve(Uint8Array.from(valueWithLength));
    };
    return Attachment;
}(ByteProcessor));
exports.Attachment = Attachment;
var MandatoryAssetId = /** @class */ (function (_super) {
    __extends(MandatoryAssetId, _super);
    function MandatoryAssetId() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MandatoryAssetId.prototype.process = function (value) {
        value = blockchainifyAssetId(value);
        return Promise.resolve(base58_1.default.decode(value));
    };
    return MandatoryAssetId;
}(ByteProcessor));
exports.MandatoryAssetId = MandatoryAssetId;
var OrderType = /** @class */ (function (_super) {
    __extends(OrderType, _super);
    function OrderType() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    OrderType.prototype.process = function (value) {
        if (value === 'buy') {
            return Bool.prototype.process.call(this, false);
        }
        else if (value === 'sell') {
            return Bool.prototype.process.call(this, true);
        }
        else {
            throw new Error('There are no other order types besides "buy" and "sell"');
        }
    };
    return OrderType;
}(ByteProcessor));
exports.OrderType = OrderType;
var Recipient = /** @class */ (function (_super) {
    __extends(Recipient, _super);
    function Recipient() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Recipient.prototype.process = function (value) {
        if (value.length <= 30) {
            var aliasBytes = getAliasBytes(value);
            return Promise.resolve(Uint8Array.from(aliasBytes));
        }
        else {
            var addressBytes = base58_1.default.decode(value);
            return Promise.resolve(Uint8Array.from(addressBytes));
        }
    };
    return Recipient;
}(ByteProcessor));
exports.Recipient = Recipient;
var ScriptVersion = /** @class */ (function (_super) {
    __extends(ScriptVersion, _super);
    function ScriptVersion() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ScriptVersion.prototype.process = function (value) {
        if (isNonEmptyBase64String(value)) {
            return Promise.resolve(Uint8Array.from([constants_1.SET_SCRIPT_LANG_VERSION]));
        }
        else {
            return Promise.resolve(Uint8Array.from([0]));
        }
    };
    return ScriptVersion;
}(ByteProcessor));
exports.ScriptVersion = ScriptVersion;
var Transfers = /** @class */ (function (_super) {
    __extends(Transfers, _super);
    function Transfers() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Transfers.prototype.process = function (values) {
        var recipientProcessor = new Recipient(constants_1.STUB_NAME);
        var amountProcessor = new Long(constants_1.STUB_NAME);
        var promises = [];
        for (var i = 0; i < values.length; i++) {
            promises.push(recipientProcessor.process(values[i].recipient));
            promises.push(amountProcessor.process(values[i].amount));
        }
        return Promise.all(promises).then(function (elements) {
            var length = convert_1.default.shortToByteArray(values.length);
            var lengthBytes = Uint8Array.from(length);
            return concat_1.concatUint8Arrays.apply(void 0, [lengthBytes].concat(elements));
        });
    };
    return Transfers;
}(ByteProcessor));
exports.Transfers = Transfers;
// DATA TRANSACTIONS ONLY
var INTEGER_DATA_TYPE = 0;
var BOOLEAN_DATA_TYPE = 1;
var BINARY_DATA_TYPE = 2;
var STRING_DATA_TYPE = 3;
var IntegerDataEntry = /** @class */ (function (_super) {
    __extends(IntegerDataEntry, _super);
    function IntegerDataEntry() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    IntegerDataEntry.prototype.process = function (value) {
        return Long.prototype.process.call(this, value).then(function (longBytes) {
            var typeByte = Uint8Array.from([INTEGER_DATA_TYPE]);
            return concat_1.concatUint8Arrays(typeByte, longBytes);
        });
    };
    return IntegerDataEntry;
}(ByteProcessor));
exports.IntegerDataEntry = IntegerDataEntry;
var BooleanDataEntry = /** @class */ (function (_super) {
    __extends(BooleanDataEntry, _super);
    function BooleanDataEntry() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    BooleanDataEntry.prototype.process = function (value) {
        return Bool.prototype.process.call(this, value).then(function (boolByte) {
            var typeByte = Uint8Array.from([BOOLEAN_DATA_TYPE]);
            return concat_1.concatUint8Arrays(typeByte, boolByte);
        });
    };
    return BooleanDataEntry;
}(ByteProcessor));
exports.BooleanDataEntry = BooleanDataEntry;
var BinaryDataEntry = /** @class */ (function (_super) {
    __extends(BinaryDataEntry, _super);
    function BinaryDataEntry() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    BinaryDataEntry.prototype.process = function (value) {
        return Base64.prototype.process.call(this, value).then(function (binaryBytes) {
            var typeByte = Uint8Array.from([BINARY_DATA_TYPE]);
            return Promise.resolve(concat_1.concatUint8Arrays(typeByte, binaryBytes));
        });
    };
    return BinaryDataEntry;
}(ByteProcessor));
exports.BinaryDataEntry = BinaryDataEntry;
var StringDataEntry = /** @class */ (function (_super) {
    __extends(StringDataEntry, _super);
    function StringDataEntry() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    StringDataEntry.prototype.process = function (value) {
        return StringWithLength.prototype.process.call(this, value).then(function (stringBytes) {
            var typeByte = Uint8Array.from([STRING_DATA_TYPE]);
            return concat_1.concatUint8Arrays(typeByte, stringBytes);
        });
    };
    return StringDataEntry;
}(ByteProcessor));
exports.StringDataEntry = StringDataEntry;
var DataEntries = /** @class */ (function (_super) {
    __extends(DataEntries, _super);
    function DataEntries() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DataEntries.prototype.process = function (entries) {
        var _this = this;
        var lengthBytes = Uint8Array.from(convert_1.default.shortToByteArray(entries.length));
        if (entries.length) {
            return Promise.all(entries.map(function (entry) {
                var prependKeyBytes = function (valueBytes) {
                    return StringWithLength.prototype.process.call(_this, entry.key).then(function (keyBytes) {
                        return concat_1.concatUint8Arrays(keyBytes, valueBytes);
                    });
                };
                switch (entry.type) {
                    case 'integer':
                        return IntegerDataEntry.prototype.process.call(_this, entry.value).then(prependKeyBytes);
                    case 'boolean':
                        return BooleanDataEntry.prototype.process.call(_this, entry.value).then(prependKeyBytes);
                    case 'binary':
                        return BinaryDataEntry.prototype.process.call(_this, entry.value).then(prependKeyBytes);
                    case 'string':
                        return StringDataEntry.prototype.process.call(_this, entry.value).then(prependKeyBytes);
                    default:
                        throw new Error("There is no data type \"" + entry.type + "\"");
                }
            })).then(function (entriesBytes) {
                var bytes = concat_1.concatUint8Arrays.apply(void 0, [lengthBytes].concat(entriesBytes));
                if (bytes.length > constants_1.DATA_ENTRIES_BYTE_LIMIT)
                    throw new Error('Data transaction is too large (140KB max)');
                return bytes;
            });
        }
        else {
            return Promise.resolve(Uint8Array.from([0, 0]));
        }
    };
    return DataEntries;
}(ByteProcessor));
exports.DataEntries = DataEntries;
//# sourceMappingURL=ByteProcessor.js.map