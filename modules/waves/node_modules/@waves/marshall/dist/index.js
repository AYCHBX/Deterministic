"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var txSchemas_1 = require("./txSchemas");
var serialize_1 = require("./serialize");
var parse_1 = require("./parse");
var txToJson_1 = require("./txToJson");
var binary;
(function (binary) {
    function serializeTx(tx, longFactory) {
        var type = tx.type, version = tx.version;
        var schema = getSchema(type, version);
        return serialize_1.serializerFromSchema(schema, longFactory)(tx);
    }
    binary.serializeTx = serializeTx;
    /**
     * This function cannot transactions without version
     */
    function parseTx(bytes, longFactory) {
        var _a = parse_1.parseHeader(bytes), type = _a.type, version = _a.version;
        var schema = getSchema(type, version);
        return parse_1.parserFromSchema(schema, longFactory)(bytes).value;
    }
    binary.parseTx = parseTx;
    function serializeOrder(ord, longFactory) {
        var version = ord.version;
        var schema = version == 2 ? txSchemas_1.orderSchemaV2 : txSchemas_1.orderSchemaV0;
        return serialize_1.serializerFromSchema(schema, longFactory)(ord);
    }
    binary.serializeOrder = serializeOrder;
    /**
     * This function cannot parse OrderV1, which doesn't have version field
     */
    function parseOrder(bytes, longFactory) {
        return parse_1.parserFromSchema(txSchemas_1.orderSchemaV2, longFactory)(bytes).value;
    }
    binary.parseOrder = parseOrder;
})(binary = exports.binary || (exports.binary = {}));
var json;
(function (json) {
    function parseTx(str, lf) {
        var safeStr = str.replace(/(".+?"[ \t\n]*:[ \t\n]*)(\d{15,})/gm, '$1"$2"');
        var tx = JSON.parse(safeStr);
        //ToDo: rewrite. Now simply serializes and then parses with long  factory to get right long types
        return lf ? convert(tx, lf) : tx;
    }
    json.parseTx = parseTx;
    function stringifyTx(tx) {
        var txWithStrings = convert(tx);
        //TODO: remove this when contract invocation tx is fixed
        if (tx.type === 16) {
            txWithStrings = tx;
        }
        return txToJson_1.txToJson(txWithStrings);
    }
    json.stringifyTx = stringifyTx;
})(json = exports.json || (exports.json = {}));
function convert(tx, toLf, fromLf) {
    return __assign({}, binary.parseTx(binary.serializeTx(tx, fromLf), toLf), { proofs: tx.proofs });
}
exports.convert = convert;
function getSchema(type, version) {
    var schemas = txSchemas_1.schemasByTypeMap[type];
    if (typeof schemas !== 'object') {
        throw new Error("Incorrect tx type: " + type);
    }
    var schema = schemas[version || 0];
    if (typeof schema !== 'object') {
        throw new Error("Incorrect tx version: " + version);
    }
    return schema;
}
exports.getSchema = getSchema;
//# sourceMappingURL=index.js.map