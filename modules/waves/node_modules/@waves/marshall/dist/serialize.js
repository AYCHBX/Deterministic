"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var serializePrimitives_1 = require("./serializePrimitives");
var utils_1 = require("./libs/utils");
var txSchemas_1 = require("./txSchemas");
// FixMe: currently longfactory does nothing. Maybe we should remove it altogether
exports.serializerFromSchema = function (schema, lf) { return function (obj) {
    //let result = Uint8Array.from([]);
    var serializer, itemBytes;
    if (schema.type === 'array') {
        serializer = exports.serializerFromSchema(schema.items, lf);
        itemBytes = utils_1.concat.apply(void 0, __spread(obj.map(function (item) { return serializer((item)); })));
        return utils_1.concat((schema.toBytes || serializePrimitives_1.SHORT)(obj.length), itemBytes);
    }
    else if (schema.type === 'object') {
        var objBytes_1 = Uint8Array.from([]);
        if (schema.optional && obj == null) {
            return Uint8Array.from([0]);
        }
        schema.schema.forEach(function (field) {
            serializer = exports.serializerFromSchema(field, lf);
            itemBytes = serializer(obj[field.name]);
            objBytes_1 = utils_1.concat(objBytes_1, itemBytes);
        });
        if (schema.withLength)
            objBytes_1 = utils_1.concat(serializePrimitives_1.SHORT(objBytes_1.length), objBytes_1);
        if (schema.optional)
            objBytes_1 = utils_1.concat([1], objBytes_1);
        return objBytes_1;
    }
    else if (schema.type === 'anyOf') {
        var type = obj[schema.discriminatorField || 'type'];
        var typeSchema_1 = schema.items.get(type);
        if (typeSchema_1 == null) {
            throw new Error("Serializer Error: Unknown anyOf type: " + schema.discriminatorField + "." + type);
        }
        var typeCode = __spread(schema.items.values()).findIndex(function (schema) { return schema === typeSchema_1; });
        serializer = exports.serializerFromSchema(typeSchema_1, lf);
        itemBytes = serializer(obj[schema.valueField || 'value']);
        return utils_1.concat((schema.toBytes || serializePrimitives_1.BYTE)(typeCode), itemBytes);
    }
    else if (schema.type === 'primitive' || schema.type === undefined) {
        return schema.toBytes(obj);
    }
    else if (schema.type === 'dataTxField') {
        var keyBytes = txSchemas_1.txFields.stringField('').toBytes(obj.key);
        var type = obj.type;
        var typeSchema_2 = schema.items.get(type);
        if (typeSchema_2 == null) {
            throw new Error("Serializer Error: Unknown dataTxField type: " + type);
        }
        var typeCode = __spread(schema.items.values()).findIndex(function (schema) { return schema === typeSchema_2; });
        serializer = exports.serializerFromSchema(typeSchema_2, lf);
        itemBytes = serializer(obj.value);
        return utils_1.concat(keyBytes, serializePrimitives_1.BYTE(typeCode), itemBytes);
    }
    else {
        throw new Error("Serializer Error: Unknown schema type: " + schema.type);
    }
}; };
//# sourceMappingURL=serialize.js.map