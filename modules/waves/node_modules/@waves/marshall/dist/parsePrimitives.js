"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Long = require("long");
var Utf8ArrayToStr_1 = require("./libs/Utf8ArrayToStr");
var base58_1 = require("./libs/base58");
var Base64 = require("base64-js");
exports.ALIAS_VERSION = 2;
var LENGTH_SIZE = 2;
exports.P_OPTION = function (p) { return function (bytes, start) {
    if (start === void 0) { start = 0; }
    if (bytes[start] === 0)
        return { value: undefined, shift: 1 };
    var result = p(bytes, start + 1);
    return { value: result.value, shift: result.shift + 1 };
}; };
exports.P_BYTE = function (bytes, start) {
    if (start === void 0) { start = 0; }
    return ({ value: bytes[start], shift: 1 });
};
exports.P_SHORT = function (bytes, start) {
    if (start === void 0) { start = 0; }
    return ({ value: 256 * bytes[start] + bytes[start + 1], shift: 2 });
};
exports.P_INT = function (bytes, start) {
    if (start === void 0) { start = 0; }
    return ({ value: Math.pow(2, 24) * bytes[start] + Math.pow(2, 16) * bytes[start + 1] + Math.pow(2, 8) * bytes[start + 2] + bytes[start + 3], shift: 4 });
};
exports.P_LONG = function (bytes, start) {
    if (start === void 0) { start = 0; }
    return ({
        value: Long.fromBytesBE(Array.from(bytes.slice(start, start + 8))).toString(),
        shift: 8
    });
};
exports.P_BOOLEAN = function (bytes, start) {
    if (start === void 0) { start = 0; }
    var value = !!bytes[start];
    return { value: value, shift: 1 };
};
exports.P_STRING_FIXED = function (len) { return function (bytes, start) {
    if (start === void 0) { start = 0; }
    var value = Utf8ArrayToStr_1.Utf8ArrayToStr(bytes.slice(start, start + len));
    return { shift: len, value: value };
}; };
exports.P_STRING_VAR = function (lenParser) { return function (bytes, start) {
    if (start === void 0) { start = 0; }
    var lengthInfo = lenParser(bytes, start);
    var value = exports.P_STRING_FIXED(lengthInfo.value)(bytes, start + lengthInfo.shift).value;
    return { shift: lengthInfo.value + lengthInfo.shift, value: value };
}; };
exports.P_BASE58_FIXED = function (len) { return function (bytes, start) {
    if (start === void 0) { start = 0; }
    var value = base58_1.default.encode(bytes.slice(start, start + len));
    return { value: value, shift: len };
}; };
exports.P_BASE58_VAR = function (lenParser) { return function (bytes, start) {
    if (start === void 0) { start = 0; }
    var lengthInfo = lenParser(bytes, start);
    var value = exports.P_BASE58_FIXED(lengthInfo.value)(bytes, start + LENGTH_SIZE).value;
    return { shift: lengthInfo.value + LENGTH_SIZE, value: value };
}; };
exports.P_BASE64 = function (lenParser) { return function (bytes, start) {
    if (start === void 0) { start = 0; }
    var lengthInfo = lenParser(bytes, start);
    var value = "base64:" + Base64.fromByteArray(bytes.slice(start + lengthInfo.shift, start + lengthInfo.shift + lengthInfo.value));
    return { shift: lengthInfo.value + lengthInfo.shift, value: value };
}; };
var byteToString = function (shift) { return function (bytes, start) {
    var value = Utf8ArrayToStr_1.Utf8ArrayToStr(bytes.slice(start, start + shift));
    return { shift: shift, value: value };
}; };
exports.byteToStringWithLength = function (bytes, start) {
    if (start === void 0) { start = 0; }
    var lengthInfo = exports.P_SHORT(bytes, start);
    var value = byteToString(lengthInfo.value)(bytes, start + LENGTH_SIZE).value;
    return { shift: lengthInfo.value + LENGTH_SIZE, value: value };
};
exports.byteToBase58 = function (bytes, start, length) {
    if (start === void 0) { start = 0; }
    var shift = length || 32;
    var value = base58_1.default.encode(bytes.slice(start, start + shift));
    return { value: value, shift: shift };
};
exports.byteToBase58WithLength = function (bytes, start) {
    if (start === void 0) { start = 0; }
    var lenInfo = exports.P_SHORT(bytes, start);
    var value = base58_1.default.encode(bytes.slice(start + lenInfo.shift, start + lenInfo.shift + lenInfo.value));
    return { value: value, shift: lenInfo.shift + lenInfo.value };
};
exports.byteToAddressOrAlias = function (bytes, start) {
    if (start === void 0) { start = 0; }
    if (bytes[start] === exports.ALIAS_VERSION) {
        var aliasData = exports.byteToStringWithLength(bytes, start + 2);
        return { shift: aliasData.shift + 2, value: aliasData.value };
    }
    else {
        return exports.byteToBase58(bytes, start, 26);
    }
};
exports.byteNewAliasToString = function (bytes, start) {
    if (start === void 0) { start = 0; }
    var shift = exports.P_SHORT(bytes, start).value + LENGTH_SIZE;
    var value = exports.byteToStringWithLength(bytes, start).value;
    return { shift: shift, value: value };
};
exports.byteToScript = function (bytes, start) {
    if (start === void 0) { start = 0; }
    var VERSION_LENGTH = 1;
    if (bytes[start] === 0) {
        return { shift: VERSION_LENGTH, value: null };
    }
    var lengthInfo = exports.P_SHORT(bytes, start + VERSION_LENGTH);
    var from = start + VERSION_LENGTH + lengthInfo.shift;
    var to = start + VERSION_LENGTH + lengthInfo.shift + lengthInfo.value;
    var value = "base64:" + Base64.fromByteArray(bytes.slice(from, to));
    return { value: value, shift: to - start };
};
//# sourceMappingURL=parsePrimitives.js.map