"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var parsePrimitives_1 = require("./parsePrimitives");
var utils_1 = require("./libs/utils");
exports.parserFromSchema = function (schema, lf) { return function (bytes, start) {
    if (start === void 0) { start = 0; }
    var _a;
    var cursor = start;
    if (schema.type === 'array') {
        var result_1 = [];
        var _b = (schema.fromBytes || parsePrimitives_1.P_SHORT)(bytes, start), len = _b.value, shift = _b.shift;
        cursor += shift;
        utils_1.range(0, len).forEach(function (_) {
            var parser = exports.parserFromSchema(schema.items, lf);
            var _a = parser(bytes, cursor), value = _a.value, shift = _a.shift;
            result_1.push(value);
            cursor += shift;
        });
        return { value: result_1, shift: cursor - start };
    }
    else if (schema.type === 'object') {
        if (schema.optional) {
            var exists = bytes[cursor] === 1;
            cursor += 1;
            if (!exists)
                return { value: undefined, shift: 1 };
        }
        //we don't need object length to parse it since we have schema of all its fields
        if (schema.withLength)
            cursor += 2;
        var result_2 = {};
        schema.schema.forEach(function (field) {
            var parser = exports.parserFromSchema(field, lf);
            var _a = parser(bytes, cursor), value = _a.value, shift = _a.shift;
            cursor += shift;
            if (value !== undefined) {
                result_2[field.name] = value;
            }
        });
        return { value: result_2, shift: cursor - start };
    }
    else if (schema.type === 'anyOf') {
        var typeInfo = (schema.fromBytes || parsePrimitives_1.P_BYTE)(bytes, cursor);
        cursor += typeInfo.shift;
        var item = Array.from(schema.items.values())[typeInfo.value];
        var parser = exports.parserFromSchema(item, lf);
        var _c = parser(bytes, cursor), value = _c.value, shift = _c.shift;
        cursor += shift;
        var discriminatorField = schema.discriminatorField || 'type';
        var discriminatorValue = __spread(schema.items.keys())[typeInfo.value];
        var valueField = schema.valueField || 'value';
        return {
            value: (_a = {},
                _a[discriminatorField] = discriminatorValue,
                _a[valueField] = value,
                _a),
            shift: cursor - start
        };
    }
    else if (schema.type === 'dataTxField') {
        var key = parsePrimitives_1.byteToStringWithLength(bytes, cursor);
        cursor += key.shift;
        var dataType_1 = parsePrimitives_1.P_BYTE(bytes, cursor);
        cursor += dataType_1.shift;
        var itemRecord = __spread(schema.items).find(function (_, i) { return i === dataType_1.value; });
        if (!itemRecord) {
            throw new Error("Parser Error: Unknown dataTxField type: " + dataType_1.value);
        }
        var parser = exports.parserFromSchema(itemRecord[1], lf);
        var result = parser(bytes, cursor);
        //cursor += result.shift;
        return {
            value: {
                value: result.value,
                key: key.value,
                type: itemRecord[0]
            },
            shift: result.shift + key.shift + dataType_1.shift
        };
    }
    else if (schema.type === 'primitive' || schema.type === undefined) {
        var parser = schema.fromBytes;
        var _d = parser(bytes, start), value = _d.value, shift = _d.shift;
        //Capture LONG Parser and convert strings desired instance if longFactory is present
        if (parser === parsePrimitives_1.P_LONG && lf) {
            value = lf.fromString(value);
        }
        return { value: value, shift: shift };
    }
    else {
        throw new Error("Parser Error: Unknown schema type: " + schema.type);
    }
}; };
exports.parseHeader = function (bytes) { return ({
    type: parsePrimitives_1.P_BYTE(bytes).value,
    version: parsePrimitives_1.P_BYTE(bytes, 1).value
}); };
//# sourceMappingURL=parse.js.map