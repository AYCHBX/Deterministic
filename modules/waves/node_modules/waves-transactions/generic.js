"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const waves_crypto_1 = require("waves-crypto");
const axios_1 = __importDefault(require("axios"));
exports.mapObj = (obj, f) => Object.entries(obj).map(([k, v]) => [k, f(v)])
    .reduce((acc, [k, v]) => (Object.assign({}, acc, { [k]: v })), {});
function getSenderPublicKey(seedsAndIndexes, params) {
    if (seedsAndIndexes.length === 0 && params.senderPublicKey == null)
        throw new Error('Please provide either seed or senderPublicKey');
    else {
        return params.senderPublicKey || waves_crypto_1.publicKey(seedsAndIndexes[0][0]);
    }
}
exports.getSenderPublicKey = getSenderPublicKey;
exports.base64Prefix = (str) => str == null || str.slice(0, 7) === 'base64:' ? str : 'base64:' + str;
function addProof(tx, proof, index) {
    if (index == null) {
        tx.proofs = [...tx.proofs, proof];
        return tx;
    }
    if (tx.proofs != null && !!tx.proofs[index])
        throw new Error(`Proof at index ${index} already exists.`);
    for (let i = tx.proofs.length; i < index; i++)
        tx.proofs.push('');
    tx.proofs[index] = proof;
    return tx;
}
exports.addProof = addProof;
function convertToPairs(seedObj) {
    //Due to typescript duck typing, 'string' type satisfies IIndexSeedMap interface. Because of this we should typecheck against string first
    if (seedObj == null) {
        return [];
    }
    else if (typeof seedObj === 'string') {
        return [[seedObj, undefined]];
    }
    else if (Array.isArray(seedObj)) {
        return seedObj.map((s, i) => [s, i]).filter(([s, _]) => s);
    }
    else {
        const keys = Object.keys(seedObj).map(k => parseInt(k)).filter(k => !isNaN(k)).sort();
        return keys.map(k => [seedObj[k], k]);
    }
}
exports.convertToPairs = convertToPairs;
exports.isOrder = (p) => p.assetPair !== undefined;
exports.delay = (timeout) => {
    const t = {};
    const p = new Promise((resolve, _) => {
        t.resolve = resolve;
        t.id = setTimeout(() => resolve(), timeout);
    });
    p.cancel = () => { t.resolve(); clearTimeout(t.id); };
    return p;
};
exports.waitForTx = (txId, timeout, apiBase) => __awaiter(this, void 0, void 0, function* () {
    const promise = () => axios_1.default.get(`transactions/info/${txId}`, { baseURL: apiBase })
        .then(x => x.data).catch(_ => exports.delay(1000).then(_ => promise()));
    const t = exports.delay(timeout);
    const r = yield Promise.race([t.then(x => Promise.reject('timeout')), promise()]);
    t.cancel();
    return r;
});
function networkByte(p, def) {
    switch (typeof p) {
        case 'string':
            return p.charCodeAt(0);
        case 'number':
            return p;
        default:
            return def;
    }
}
exports.networkByte = networkByte;
function fee(params, def) {
    if (params.fee)
        return params.fee;
    if (!params.additionalFee)
        return def;
    return def + params.additionalFee;
}
exports.fee = fee;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJpYy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9nZW5lcmljLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFFQSwrQ0FBd0M7QUFDeEMsa0RBQTBCO0FBRWIsUUFBQSxNQUFNLEdBQUcsQ0FBeUIsR0FBaUIsRUFBRSxDQUFZLEVBQWdCLEVBQUUsQ0FDOUYsTUFBTSxDQUFDLE9BQU8sQ0FBSSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFnQixDQUFDO0tBQzVELE1BQU0sQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsbUJBQUssR0FBVSxJQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFFLEVBQUUsRUFBaUIsQ0FBQyxDQUFBO0FBSXpFLFNBQWdCLGtCQUFrQixDQUFDLGVBQW9DLEVBQUUsTUFBdUI7SUFDOUYsSUFBSSxlQUFlLENBQUMsTUFBTSxLQUFLLENBQUMsSUFBSSxNQUFNLENBQUMsZUFBZSxJQUFJLElBQUk7UUFDaEUsTUFBTSxJQUFJLEtBQUssQ0FBQywrQ0FBK0MsQ0FBQyxDQUFDO1NBQzlEO1FBQ0gsT0FBTyxNQUFNLENBQUMsZUFBZSxJQUFJLHdCQUFTLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUE7S0FDbEU7QUFDSCxDQUFDO0FBTkQsZ0RBTUM7QUFFWSxRQUFBLFlBQVksR0FBRyxDQUFDLEdBQWtCLEVBQUUsRUFBRSxDQUFDLEdBQUcsSUFBSSxJQUFJLElBQUksR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEtBQUssU0FBUyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLFNBQVMs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